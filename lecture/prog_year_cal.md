# いちねんカレンダー機能を作る

Today機能を一から自分で作るのは意外と難しいので、Google先生に頼ってみました。現在の日時情報を知るには、コンピュータにある日付情報をどうにかして取得する必要があります。こういった処理は、通常OSから提供される機能を使う事になるので、標準ライブラリ関数を使うのが一般的です。



次に、いちねんカレンダー機能の実現方法について考えてみましょう。

## 出力イメージを考える

出力イメージを示します。なお、レイアウトが崩れてしまいますので、MS明朝などの固定ピッチフォーマットでご覧下さい。プログラムでは上の行から順番に出力する事になるので、概ね以下のような処理順序になります

1. 「xx月のカレンダー」を出力する(a)
2. 曜日部分を出力する(b)
3. 開始曜日まで空白を入れる(c)
4. 日を1から順に出力していき、土曜日の部分で折り返す(d)
5. 出力している日が月末日に到達したら処理を終了

```
 1月のカレンダー ←(a)

日 月 火 水 木 金 土 ←(b)
       1  2  3  4  5 ←(c)(d)
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31 ←(e)
```

#### カレンダーを作るには？

では、具体的にどうすればカレンダーを作成出来るでしょうか？こういう時は、

「カレンダーを作る為には、何が必要か？」

を考えてみるとヒントが得られます。今回のケースであれば**どういった情報があれば、カレンダーを作成する事が出来る**のかを考えてみます。このようにソフトウェアを組む上で必要なデータを考える事は、プログラミングにおいて最も重要なものとされます。著名なソフトウェア工学者のロブ・パイクが述べた言葉に以下のようなものがあります。

> データが最も重要である。 正しいデータ構造と編成を選択すれば、アルゴリズムは自明のものとなります。アルゴリズムではなく、データ構造こそがプログラミングの中心です

## データ構造

では、いちねんカレンダー機能において必要なデータ構造を考えてみます。

カレンダーの構造を思い浮かべて考えたところ、以下のルールで成り立っているようです。

- 月は1～12月までの12進数
- 日は必ず1日から始まるが、終わりは28～31日まである
- 曜日は年月日によって変わり、例えば2018年と2019年の1/1の曜日は異なる

これらの情報から**特定月のカレンダーを作成する場合に必要なもの**は

- その月が何日まであるのか？
- その月の1日は何曜日から始まるのか？

の二点が決まれば良いようです。従ってこれをプログラムにすれば特定月のカレンダーを作成出来そうです

- その月が何日まであるのか？
- その月は何曜日まであるのか？

では、早速これをデータとして定義してみましょう

### カレンダー情報型を定義する

| データ名 | 設定値制限                           | 型     |
| -------- | ------------------------------------ | ------ |
| 月末     | 28～31                               | 整数型 |
| 開始曜日 | "月"、"火"、"水"、"木"、"月"、"月"、 | 列挙型 |

月ごとに上のデータがあれば良さそうです。では、C言語でこれを表現してみます。

```cpp
// 曜日を示す列挙型
typedef enum
{
    Sun = 0, // 日曜日
    Mon, // 月曜日
    Tue, // 火曜日
    Wed, // 水曜日
    Thu; // 木曜日
    Fri; // 金曜日
    Sat; // 土曜日
}eWeekday;

// カレンダーを作るのに必要な情報を示す構造体型
typdef struct{
    int      last; // その月の最終日
    eWeekday weekday; // 曜日
}MonthInfo;
```

MonthInfo型の情報を使えば、例えば2018/12であれば**土曜日から始まり、31日で終わる**ので、以下のようにデータを定義する事が出来ます

```cpp
MonthInfo month_info_2018_12;
month_info_2018_12.weekday  = Sat; // 2018/12は土曜日から始まる
month_info_2018_12.last_day = 31;  // 2018/12は31日まで
```

さらに、この型を配列にすれば2019年データを定義する事が出来ます

```cpp
MonthInfo month_info_2019[] = {
    { 31, Tue }, // 2019/01
    { 28, Fri }, // 2019/02
    { 31, Fri }, // 2019/03
    { 30, Mon }, // 2019/04
    { 31, Wed }, // 2019/05
    { 30, Sat }, // 2019/06
    { 31, Mon }, // 2019/07
    { 31, Thu }, // 2019/08
    { 30, Sun }, // 2019/09
    { 31, Tue }, // 2019/10
    { 30, Fri }, // 2019/11
    { 31, Sun }, // 2019/12
};
```

これでカレンダーを作る為に必要なデータが揃いましたので、今度はそのデータを使ってカレンダーを作成していきましょう。(計算機学においては「プログラム = データ構造＋アルゴリズム」と呼ばれますが、上のがデータ構造で、出力処理を行うのがアルゴリズムといった所です)

## タイトル/曜日部分を出力する

では、出力イメージのここの部分の出力を行ってみましょう。

```
 1月のカレンダー
日 月 火 水 木 金 土
```

恐らくは最初に学ぶであろうprintf()関数を使いましょう。

```cpp
int month = 1;
printf( "%s月のカレンダー\n\n", month );
printf( "日 月 火 水 木 金 土\n" );
```

## "日"出力前の空白を出力する

カレンダーの曜日部分は日から始まるので、例えば1日が火曜日から始まる場合には日・月を飛ばしてから1日を始める必要があります。何やら少し難しそうな感じがしますが、二つほどC言語知識が必要になるので、ここで説明します。先ずは列挙型と整数値の関係について述べます

### 列挙型と整数値の関係

```
日 月 火 水 木 金 土
      1  2  3  4  5
<---->この部分をスキップする
```

カレンダーを作成するのに必要な情報はMonthInfoに含まれていますが、この中の**開始曜日の情報を示すMonthInfo.weekday**を使用します。C言語の列挙型の特徴として、列挙型のそれぞれの値(正式名称は列挙子と言いますが、プロでも正確な呼称を知っている人は稀です)は、整数値として扱う事が出来ます

```cpp
// 曜日を示す列挙型
typedef enum
{
    Sun = 0, // 日曜日
    Mon, // 月曜日
    Tue, // 火曜日
    Wed, // 水曜日
    Thu; // 木曜日
    Fri; // 金曜日
    Sat; // 土曜日
}eWeekday;
```

この定義であれば、以下の表のように整数値が割り当てられます。

| 列挙子 | 整数値 |
| ------ | ------ |
| Sun    | 0      |
| Mon    | 1      |
| Tue    | 2      |
| Wed    | 3      |
| Thu    | 4      |
| Fri    | 5      |
| Sat    | 6      |

すなわち、**曜日によって読み飛ばす量はこの整数値側の値を使用する**事が出来ます。しかし、読み飛ばすといってもコンピュータに「２つ読み飛ばして」と命令しても、コンピュータにはどういう単位で読み飛ばせばよいのかまでは判断出来ない為、具体的な読み飛ばし量を教えてやる必要があります。この時に使用するのが**書式指定文字列**というものです。

### 書式指定文字列

プログラミング言語を学ぶ際に最初に書くプログラムは以下のようなものです

```cpp
#include <stdio.h>

int main( void )
{
    printf( "Hello World\n" );
    return 0;
}
```

ここで出てくるprintf()関数への引数として使用されるのが書式指定文字列というもので、第一引数で渡されます。これは、出力フォーマットを指定する機能を有する特殊な文字列となっていて、指定された変数に対して出力形式を指定出来るようになっています。

```cpp
int val = 123;
printf( "val is %d\n",   val ); // val is 123(valをそのまま%dの位置に表示)
printf( "val is %4d\n",  val ); // val is  123(valを4桁幅の数字として出力)
printf( "val is %04d\n", val ); // val is 0123(valを4桁幅かつ0埋めの数字として出力)
```

読み飛ばしを考える際には、曜日の行と日の行の文字列数が一致するようにスキップしてやる必要があります。以下に示しましたが、全角文字である漢字は2文字分の幅を取ると、次の曜日との半角スペースと合わせて3文字分の文字幅を取るので、日の出力幅は2文字分を取ればよい事になります

```cpp
月_ // 曜日
 1_ // 日
012 // 文字列幅
    
printf( "月 "); // 全角文字(2文字分)と半角スペース1つの合計3文字幅
printf( "   ", day ); // 半角スペース3つ分
```

### 読み飛ばし部分のコード

ここまでで読み飛ばしの準備が出来ましたので、ソースコードを示します

```cpp
eWeekday weekday = Tue; // 火曜日までスキップする
int skip = ( int )weekday; // 列挙型を整数として扱う
// for文でスキップ数分処理を繰り返す( idxが0～1の間{}の処理を繰り返す )
for( int idx = 0; idx < skip; idx++ )
{
    	printf( "   " ); // 半角スペース3つ分の空白を主著rくする
}
```

## 日部分の出力

最後に日部分の出力を行います。この部分ですね。

```
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31 ←(e)
```

先ずは処理の流れをざっと考えてみましょう。

1. 1から月末までの数字を出力する)(printf()で3文字幅にする)
2. 土の位置に差し掛かったら折り返す
3. 月末まで出力が終わったらカレンダーの完成

1日の出力位置までの読み飛ばしは終わっているので、あとは土曜の位置での折り返しですね。**1日から順番に処理を進めるに当たって、一緒に曜日も進めていけば折り返し処理が実現**出来そうですね。という訳で新たに**今日がいつなのかを示すデータ構造**を定義しました。

```cpp
// 本日を示す構造体
typedef struct
{
    int year;
    int month;
    int day;
    eWeekday weekday;
}TodayInfo;
```
また日を進める際には色々な処理を行う必要があるので、専用の関数を用意する事にします。
```cpp
// 曜日を進める
static eWeekday
next_weekday( eWeekday current )
{
    switch( current )
    {
    case eSun: return eMon;
    case eMon: return eTue;
    case eTue: return eWed;
    case eWed: return eThu;
    case eThu: return eFri;
    case eFri: return eSat;
    case eSat: return eSun;
    default: assert( 0 ); // ここの入る事はないので、万一入ったら異常終了させる
    }
} // next_weekday()

// TodayInfo型データを一日進める関数
// 引数のeomはend of monthで月末の意
static void
StepTodayInfo( TodayInfo *today_info, int eom )
{
    if( today_info->day != eom ) // 月末以外の場合
    {
        ( today_info->day )++; // 日を一日進める
    }
    else // 月末の場合
    {
        today_info->day = 1; // 1日に戻す
        ( today_info->month )++; // 月を1つ進める
        if( today_info->month == 13 ) // 年末の場合は更に年を進める
        {
            ( today_info->year )++;
            today_info->month = 1; // 1月に戻す
        }
    }
    
    // 曜日を進める
    today_info->weekday = next_weekday( today_info->weekday );
} // StepTodayInfo()
```

### MEMO：スコープの考え方

上で定義した関数はそれぞれstatic関数として定義しています。これは**その関数がどこから使えるか？**を決めるもので、**スコープと呼ばれる定義の有効範囲を示す**ものとなります。

- static関数(ローカルスコープ)
  - その関数が定義されたファイル内でのみ有効
- 何も付けていない関数(グローバルスコープ)
  - そのソースコードを含むアプリケーションなら、どこからでも使える

「大は小を兼ねるから、グローバルスコープだけでいいよ」

と思われるかもしれませんが、大人数で開発をしていると

「AさんとBさんが同じ名前の関数を定義してしまった」

という事が頻繁に発生し、リンクの際に多重定義エラーを引き起こします。

### 日部分を出力する

ここまでに示したデータ構造と関数を使えば、日部分は以下のように書く事が出来ます

```cpp
{
    TodayInfo today; // 本日を示すデータ
    
    // まず本日のデータをセットしておく
    today.year = 2019;
    today.month = month;
    today.day = 1;
    today.weekday = pInfo->weekday;

    // 日部分を出力する。1日から月末までループするfor文で書く
    for( int loop_count = 0; loop_count < pInfo->last; loop_count++ )
    {
        // 今日の日を出力する( 2桁幅 )
        printf( "%2d ", today.day );
        // 土曜日まで出力したら、改行して折り返す
        if( today.weekday == eSat )
        {
            printf( "\n" );
        }
        // 本日のデータを一日進める
        StepTodayInfo( &today, pInfo->last ); // 1日進める
    }
	printf( "\n" );    
}
```

