## 処理を考える

ここまでで、用意すべき機能が見えてきました。あとは表示方法や起動方法なんかも考える所ですが、その辺はあまり凝った事をやるつもりはないのですっ飛ばします。

コンピュータに処理をさせる為には、以下のように作業を進めます

1. 処理の流れを考える
2. 処理の流れをプログラミング言語で書く
3. コンピュータに実行させる

では、処理の考えを考えてみましょう

### 処理の流れを考える

先ずは、カレンダーをどうやって作るか？を考えてみましょう。

日時情報を取得する為には便利なライブラリが沢山用意されているので、本来であればイチから作る必要はありません。しかし、今年一年分という事であれば簡単に作れそうなので自作してみましょう

#### カレンダーを作るには？

では、具体的にはどうやればカレンダーを用意する事が出来るでしょう？

先ずは**今月分のカレンダーを自作**する事を考えてみましょう。カレンダーは以下のルールで成り立っているようです

- 月は、1～12月までの12進数
- 日は、必ず1日から始まるが、終わりは28～31日まである
- 曜日は、年月日によって変わり、例えば2018年と2019年の1/1の曜日は異なる

これらの情報から、特定の月のカレンダーを用意するなら

- その月が何日まであるのか？
- その月の1日は何曜日から始まるのか？

の二点が決まれば作成出来そうです。なので、プログラミング開発言語で、以下の情報を記述出来れば特定の年月日を知る事が出来ます

- その月が何日まであるのか？
- その月は何曜日まであるのか？

では、早速これをデータとして定義してみましょう

| データ名 | 設定値制限                           |      |
| -------- | ------------------------------------ | ---- |
| 終了日時 | 28～31                               |      |
| 開始曜日 | "月"、"火"、"水"、"木"、"月"、"月"、 |      |
|          |                                      |      |

月ごとに上のデータが付いていれば良さそうです。次にC言語でこれを書いてみます

```cpp
// 曜日を示す列挙型
typedef enum
{
    Sun, // 日曜日
    Mon, // 月曜日
    Tue, // 火曜日
    Wed, // 水曜日
    Thu; // 木曜日
    Fri; // 金曜日
    Sat; // 土曜日
}eWeekday;

// カレンダーを作るのに必要な情報を示す構造体型
typdef struct{
    int      last; // その月の最終日
    eWeekday weekday; // 曜日
}Month_Info_t;
```

これらの型情報を使えば、**例えば2018/12であれば土曜日から始まり、31日で終わる**ので、以下のようにデータを定義する事が出来ます

```cpp
Month_Info_t month_info_2018_12;
month_info_2018_12.weekday  = Sat; // 2018/12は土曜日から始まる
month_info_2018_12.last_day = 31;  // 2018/12は31日まで
```

更に配列にする事で、以下のように2019年データを一気に定義する事が出来ます

```cpp
Month_Info_t month_info_2019[] = {
    { 31, Tue }, // 2019/01
    { 28, Fri }, // 2019/02
    { 31, Fri }, // 2019/03
    { 30, Mon }, // 2019/04
    { 31, Wed }, // 2019/05
    { 30, Sat }, // 2019/06
    { 31, Mon }, // 2019/07
    { 31, Thu }, // 2019/08
    { 30, Sun }, // 2019/09
    { 31, Tue }, // 2019/10
    { 30, Fri }, // 2019/11
    { 31, Sun }, // 2019/12
};
```

